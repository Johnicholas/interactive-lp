\documentclass{article}

\usepackage{amsmath, amssymb}
\usepackage{verbatim}
\usepackage{url}

% XXX add fp-macros or sth
\newcommand{\lolli}{\multimap}
\newcommand{\tensor}{\otimes}
\newcommand{\process}{\mathsf{process}}
\newcommand{\with}{\mathsf{\&}}
\newcommand{\subord}{\prec}
\newcommand{\inits}{\mathsf{initials}}
\newcommand{\interms}{\mathsf{intermediates}}
\newcommand{\terms}{\mathsf{terminals}}
\newcommand{\eps}{\epsilon}
\newcommand{\bang}{!}
\newcommand{\mon}[1]{\{#1\}}
\newcommand{\stepsto}{\rightsquigarrow}
%"proofs in the standard sequent calculus"
\newcommand{\proves}{\longrightarrow}
%"proves in the focusing system"
\newcommand{\fproves}{\Longrightarrow}
\newcommand{\atm}[1]{\mathsf{#1}}
\newcommand{\up}{\uparrow}
\newcommand{\down}{\downarrow}
\newcommand{\stable}[1]{#1\mathsf{\ stable}}
\newcommand{\aff}{@}
\newcommand{\one}{\mathrm{1}}

% epsilons
\newcommand{\nileps}{\langle\rangle}
% \newcommand{\gets}{\leftarrow}

\title{Subordination for linear, forward-chaining logic programs}
\author{Chris Martens}
\date{\today}

\begin{document}

\maketitle

\section{Language}

\subsection{The logic programming language}

Basically lollimon or linear datalog.

Terms and types that classify them
\[ t ::= ... \]
\[ \tau ::= ... \]

Predicate kinds
\[ K ::= \mathsf{rel} \mid \vec{\tau} \to K \]

Synchronous resources
\[ S ::= a(t_1, ..., t_n) \mid S \tensor S \mid \one \]

Forward-chaining, asynchronous rules
\[ A ::= \Pi \overline{x{:}\tau}. S \lolli \{S\} \]

Signatures, collections of rules
\[ \Sigma 
::= \cdot \mid \Sigma, t : \tau \mid \Sigma, a : K \mid \Sigma, r : A \]

States (linear contexts)
\[
\Delta ::= \cdot \mid \Delta, x : S
\]

Programs
\[
prog ::= (\Sigma, \Delta_0) \mid (\Sigma, \Delta_0) \proves^{?} A
\]


\subsection{The trace language}

The above describes how to populate a signature; this section should
describe how proof search is executed and traces are built.

Patterns
\[ p ::= \langle x_1, \dots, x_n \rangle \]

Rule applications
\[ R ::= r(N_1,...,N_n) \]

Traces (sequences of bindings)
\[
\eps ::= \nileps \mid \{ p \} \gets R ; \eps'
\]


Operational judgment

\[
\Sigma \vdash \eps : \Delta \stepsto \Delta'
\]
% XXX define

Pre- and post-sets of variables in a binding
% XXX define

Concurrent equality judgment
\[
\eps_1 = \eps_2
\]
% XXX define

\section{Definition of subordination}

An atomic resource $a(e)$ is {\em initial} in $\Sigma$ if it occurs in
$\Sigma$, but only to the left of an implication 
$... \tensor a(e) \tensor ... \lolli {A}$ ($a(e) \notin A$).

An atom is {\em intermediate} in $\Sigma$ if it occurs to the left of
the $\lolli$ in some rules and to the right in others.

An atom is {\em terminal} in $\Sigma$ if it occurs in $\Sigma$ and only
occurs to the right.

$\Sigma_1 \subord \Sigma_2$ iff

\begin{itemize}
\item $\interms(\Sigma_1) \cap \Sigma_2 = \emptyset$
\item $\interms(\Sigma_2) \cap \Sigma_1 = \emptyset$
\item $\inits(\Sigma_1) \cap \terms(\Sigma_2) = \emptyset$
\end{itemize}



\section{Example}

Consider the following signature.

\verbatiminput{subord-example.clf}

If we consider the signature to be divided by the comments into $\Sigma_m$,
$\Sigma_c$, and $\Sigma_i$ (for the model signature, control signature, and
mediating signature), then $\Sigma_m \subord \Sigma_c$ and $\Sigma_c
\subord \Sigma_m$. If we add in just one of the rules from $\Sigma_i$, we
get an asymmetric subordination relation. For example, let's consider
removing \verb|model-control| but keeping \verb|control-model|. This now
means that $\Sigma_c \subord \Sigma_m$.


\section{Theorem statement and proof}

If $\Sigma_1, \Sigma_2 \vdash \eps : \Delta \stepsto \Delta'$
and $\Sigma_1 \subord \Sigma_2$, then
$\eps = \eps_1 ; \eps_2$ where
$\Sigma_1 \vdash \eps_1 : \Delta \stepsto \Delta''$
and
$\Sigma_2 \vdash \eps_2 : \Delta'' \stepsto \Delta'$.

In other words, any trace run in a signature that can be divided into a
subordination relation has a prefix that can be run in only the subordinate
signature, and does not need to consider rules from the later signature. In
our example above, this means that as long as we haven't produced a
terminal atom from the control (\verb|control_terminal| being the only
one), then we only need to consider rules from $\Sigma_c$.

Proof: By induction on the structure of the trace $\eps$.

\begin{itemize}
\item Case: $\eps = \nileps$. $\eps_1 = \eps_2 = \nileps$. \checkmark
% XXX more details below about well-formedness of epsilons in their
% respective signatures
\item Case: $\eps = \{p\}\gets R; \eps'$\\
  By Lemma (below), either 
  \[ \Delta \vdash_{\Sigma_1} R : A \]
  or
  \[ \Delta \vdash_{\Sigma_2} R : A \]
  \begin{itemize}
  \item Subcase 1: 
    \[
      \Sigma_1 \vdash \{p\}\gets R 
        : \Delta^{o}, fv(R) \stepsto \Delta^{o}, bv(p)
    \]
    (and $\eps' : \Delta^o, bv(p) \stepsto \Delta'$).\\
    By IH, $\eps' = \eps_1'; \eps_2'$.\\
    Let $\eps_1$ be $\{p\} \gets R; \eps_1'$ and
    $\eps_2$ be $\eps_2'$. $\eps =\eps_1;\eps_2$ as needed.
  \item Subcase 2: $\{p\}\gets R$ is wf in $\Sigma_2$\\
    By IH, $\eps = \{p\}\gets R; \eps_1'; \eps_2'$.\\
    By definition of subordination, $bv(p)$'s types are intermediates or
    terminals of $\Sigma_2$ (because, for $R = r(e)$, initials can't appear
    on the right of the $\lolli$ in $r$'s type).\\
    Since $\eps_1'$ is well-formed in $\Sigma_1$ (also from IH),
    $bv(p) \notin \eps_1'$.\\
    Thus we can rewrite
    \[ \{p\}\gets R; \eps_1'; \eps_2' \]
    as
    \[ \eps_1'; \{p\}\gets R; \eps_2' \]
    So letting $\eps_1$ be $\eps_1'$ and $\eps_2$ be $\{p\}\gets R;
    \eps_2'$ gives us $\eps =\eps_1;\eps_2$ as needed.
  \end{itemize}
\end{itemize}

\subsection{Lemma}

If $\Sigma_1 \subord \Sigma_2$ and $\Sigma_1, \Sigma_2 \vdash p \gets
R;\eps :
\Delta \stepsto \Delta'$
then either
$\Sigma_1; \Delta \vdash R : A$
or
$\Sigma_2; \Delta \vdash R : A$.

% \bibliographystyle{plain}
% \bibliography{preproposal}

\end{document}
